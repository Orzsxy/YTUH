#通用函数-元素级 数组函数 :看作简单函数的矢量化包装器
In [61]: arr = np.arange(10)
In [62]: np.exp(arr)
Out[62]:
array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,
       5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,
       2.98095799e+03, 8.10308393e+03])
In [63]: np.sqrt(arr)
Out[63]:
array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])

#二元通用函数：
In [66]: x = np.random.randn(8)
In [67]: y = np.random.randn(8)
In [68]: x
Out[68]:
array([ 0.25275758, -1.70704776, -2.13942454, -1.06675031, -0.45456416,
        0.07936331, -2.04319942,  0.29636905])
In [69]: y
Out[69]:
array([ 0.02163524, -0.00993774,  0.90801298,  0.06724211, -1.42494841,
       -0.90014592,  0.57001954,  1.86074212])
In [70]: np.maximum(x,y) #对应元素的最大值
Out[70]:
array([ 0.25275758, -0.00993774,  0.90801298,  0.06724211, -0.45456416,
        0.07936331,  0.57001954,  1.86074212])
# 有的ufunc还返回两个数组 如 modf
In [72]: arr = np.random.randn(7)*5
In [73]: np.modf(arr)
Out[73]:
(array([-0.43438864, -0.52119832, -0.29323408,  0.90887377,  0.32439346,
        -0.27692691,  0.27245525]),
 array([ -4.,  -0.,  -1.,   3.,   2., -10.,   3.]))
In [74]: arr
Out[74]:
array([ -4.43438864,  -0.52119832,  -1.29323408,   3.90887377,
         2.32439346, -10.27692691,   3.27245525])
#常见的一元 二元 ufunc
#一元ufunc:
# abs fabs 										如果是非复数fabs更快
# sqrt											**0.5
# square										平方，相当于**2
# exp											e^
# log log10 log2 log1p							e 10 2 log(1+x)
# sign											计算各个元素的正负号 1正数 0零 -1负数
# ceil											大于等于该值的最小数
# floor 										小于等于该值的最大值
# rint											四舍五入 保留对应的dtype
# modf											返回两个独立的数组
# isnan											返回那些值是Nan 的布尔型数组
# isfinite isinf								返回布尔型数组，那些值是无穷的，不是无穷的
# cos sodh sin sinh tan tanh

# 二元ufunc:
# add subtract multiply divide floor_divide 	floor_divide 这个除法回舍去余数
# power(A,B) A^B
# maximum fmax									fmax回忽略数组中Nan
# minimun fmin 
# mod
# copysign 										将第二个元素的符号，给第一个元素
# greater greater_equal
# less less_equal
# equal not_equal
#logical_and logical_or logical_xor             % | ^



 
# 对 对应的网格点计算sqrt(x**2+y**2)
# np.meshgrid()接受两个一维数组，产生两个二维矩阵（生成网格点坐标矩阵）
In [82]: points = np.arange(-5,5,0.01)

In [83]: xs,ys = np.meshgrid(points,points) #生成网格点坐标矩阵

In [84]: xs
Out[84]:
array([[-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       ...,
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99]])

In [85]: ys
Out[85]:
array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
       ...,
       [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])
plt.imshow(z,cmap=plt.cm.gray);plt.colorbar()
plt.title("Image plot of $\sqrt{x^2 + y^2}$ for a grid of values")





#三元条件表达式的矢量函数: np.where(),可以替代： x if condition else y
# numpy这些矢量函数通常要比纯py操作快2到3个数量级
# where可以嵌套使用代替if else
In [100]: x = np.array([1.1,2.2,3.3,4.4])
In [101]: y = np.array([5.5,6.6,7.7,8.8])
In [102]: bl = np.array([True, False, True, True])
In [103]: np.where(bl,x,y)
Out[103]: array([1.1, 6.6, 3.3, 4.4])
#不使用np.where:
In [105]: result=[x if c else y for x,y,c in zip(x,y,bl)]
In [106]: result
Out[106]: [1.1, 6.6, 3.3, 4.4]
# np.where中的第二第三个参数都可以是标量值（传递给where的数组元素个数可以不相等）： 
In [108]: arr = np.random.randn(4,4)
In [109]: arr
Out[109]:
array([[-0.11690535, -0.41907211,  1.6499892 , -2.63827231],
       [ 0.64245314, -1.60710067,  2.35271156, -0.81224988],
       [ 0.06663117,  1.39319987,  1.05608671,  0.89534725],
       [-0.04614341,  0.8566481 ,  1.00889555, -0.44085777]])
In [110]: np.where(arr<0,0,arr) #操作的是视图，不对arr原型操作
Out[110]:
array([[0.        , 0.        , 1.6499892 , 0.        ],
       [0.64245314, 0.        , 2.35271156, 0.        ],
       [0.06663117, 1.39319987, 1.05608671, 0.89534725],
       [0.        , 0.8566481 , 1.00889555, 0.        ]])





#数学上计算的一些函数：
In [113]: arr
Out[113]:
array([[-0.52565318, -0.06514049,  0.77900746, -0.64749198],
       [ 1.62544032, -0.97496036, -1.33857885, -1.38542442],
       [-1.06893988,  2.25428458, -0.87300678, -1.33783729],
       [-0.26028811, -0.55900336, -0.07074519, -1.23112467],
       [-1.10851751, -1.21553539,  0.24401448, -0.63935337]])

In [114]: arr.mean() #计算平均值
Out[114]: -0.41994270020397895

In [115]: np.mean(arr) #另一种方法计算平均值
Out[115]: -0.41994270020397895

In [116]: arr.sum() #求和 
Out[116]: -8.39885400407958

In [117]: arr.mean(axis=1)  #axis指代在哪一个维度上进行操作 1 是在y轴上，0在x轴， 相对于笛卡尔坐标系的轴
Out[117]: array([-0.11481955, -0.51838083, -0.25637484, -0.53029033, -0.67984795])

In [118]: arr.sum(0) # x轴上进行求和
Out[118]: array([-1.33795836, -0.56035503, -1.25930888, -5.24123173])

In [119]: arr.sum(axis=0) #  也是x 轴上进行求和
Out[119]: array([-1.33795836, -0.56035503, -1.25930888, -5.24123173])

In [122]: arr = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
In [123]: arr.cumsum(0)
Out[123]:
array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]], dtype=int32)
### 常见的其他数学矢量函数：差不多都能指定维度
# sum mean 				长度为0的数组计算结果分别是 0 Nan
# std var 				标准差、方差， 自由度可以调默认为n
# min max 				最小、最大值，上面也讲到了maximun ufunc，只不过是二元的ufunc,这儿是一元的
# argmin argmax 		返回最大最小值的索引，
# cumsum				所有元素的累计和
# cumprod				所有元素的累计积



#布尔型的数组方法：
In [127]: arr = np.random.randn(100)
In [130]: (arr>0).sum() # 可以统计正数的个数
Out[130]: 49

In [135]: nums = np.arange(-1,3,0.5)
In [136]: nums
Out[136]: array([-1. , -0.5,  0. ,  0.5,  1. ,  1.5,  2. ,  2.5])
In [137]: nums.any() #数组中是否含有True,如果数组不是布尔型，有0为false,其他的为true
Out[137]: True
In [138]: nums.all() # 数组中是否都为true
Out[138]: False
#排序：
#多维数组的排序，只要把对应的轴号参数传入就可以针对轴进行排序
In [151]: arr=np.random.randn(5)
In [152]: arr
Out[152]: array([ 0.97852087,  0.09173878,  1.28230863,  1.53904168, -0.88547737])
In [153]: arr.sort() # 操作的不是视图，元组本身  np.sort(arr)操作的是视图
In [154]: arr
Out[154]: array([-0.88547737,  0.09173878,  0.97852087,  1.28230863,  1.53904168])

# 数组中的去重
#np.unique 返回去重并且排序后的结果
In [159]: names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
In [161]: np.unique(names)
Out[161]: array(['Bob', 'Joe', 'Will'], dtype='<U4')
In [162]: sorted(set(names)) #等价的纯Py操作

#np.in1d 判断一个数组中元素是否在另一个数组中也存在
In [163]: values = np.array([6, 0, 0, 3, 2, 5, 6])
In [164]: np.in1d(values,[2,3,6])
Out[164]: array([ True, False, False,  True,  True, False,  True])

##常见的数组集合运算：
# unique()
# intersect1d(x,y)		返回两个集合的交集，并且有序
# union1d(x,y)			返回两个集合的并集，有序
# in1d
# setdiff1d(x,y)		x-y
# setxor1d(x,y)         对称差：存在于一个数组中，但不同时存在于两个数组中
