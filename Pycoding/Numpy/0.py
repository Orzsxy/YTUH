>>> import numpy as np
#array将输入数的元组 列表等(相同的数据)转化为ndarry,可以指定dtype
# 可以指定数据类型dtype,用astype转换格式、asarray转换成ndarray对象
>>> arr = np.array(np.random.randn(2,3),dtype=np.float32)
>>> arr
array([[-0.08232219, -0.3948528 , -0.5022811 ],
       [ 0.5470062 , -0.03559234, -2.0446637 ]], dtype=float32)
>>> arrint = arr.astype(np.int32)
>>> arrint
array([[ 0,  0,  0],
       [ 0,  0, -2]])
>>> np.asarray(arrint)
array([[ 0,  0,  0],
       [ 0,  0, -2]])

>>> np.zeros((3,6))
array([[0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0.]])
>>> np.ones((2,3))
array([[1., 1., 1.],
       [1., 1., 1.]])
>>> np.empty((2,2)) #默认的是垃圾值，Numpy关注数值计算，所以默认的数据类型都是float64
array([[8.90068589e-308, 1.44635488e-307],
       [3.33773471e-307, 4.22793572e-307]])
>>> np.arange(10) #类似于内置的range，返回一个ndarray对象
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
#zeros_like 参数是一另一个数组为参数，根据参数的形状和数据类型创建一个全0的数组
>>> arr1 = np.zeros((3,6))
>>> arr2 = np.zeros_like(arr1)
>>> arr2
array([[0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0.]])
# ones ones_like接而zeros用法相同
# empty empty_like 用法也和上面相同

#创建一个单位矩阵eye、identity
>>> np.eye(3)
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
>>> np.identity(3)
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])

#数组与标量运算符也会传播到各个元素
In [3]: data = np.random.randn(2,3)

In [4]: data
Out[4]:
array([[-0.8370373 ,  0.51452343,  1.72733778],
       [ 0.90657984, -0.96116626, -0.34454691]])

In [5]: 1/data
Out[5]:
array([[-1.19468989,  1.94354608,  0.57892556],
       [ 1.10304681, -1.04040273, -2.90236241]])

In [6]: data**2
Out[6]:
array([[0.70063145, 0.26473436, 2.98369582],
       [0.821887  , 0.92384058, 0.11871257]])

In [8]: arr = np.arange(10) #一维数组也支持切片
In [9]: arr
Out[9]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
In [10]: arr[5]
Out[10]: 5
In [11]: arr[1:10:2]
Out[11]: array([1, 3, 5, 7, 9])
In [12]: arr[1:10:2] = 0
In [13]: arr
Out[13]: array([0, 0, 2, 0, 4, 0, 6, 0, 8, 0])
#访问二维的方式
In [3]: arr = np.array([[1,2,3],[4,5,6],[7,8,9]])
In [4]: arr
Out[4]:
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
In [5]: arr[2]
Out[5]: array([7, 8, 9])
In [6]: arr[0,0]
Out[6]: 1
In [7]: arr[0][0]
Out[7]: 1

#对高维数组，数组和标量都可以赋给对应的对象
In [9]: arr = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])
In [11]: arr[0]
Out[11]:
array([[1, 2, 3],
       [4, 5, 6]])
In [12]: arr[0][1]
Out[12]: array([4, 5, 6])
In [13]: old_values = arr[0].copy()
In [14]: arr[0] = 0
In [15]: arr
Out[15]:
array([[[ 0,  0,  0],
        [ 0,  0,  0]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
In [16]: arr[0] = old_values
In [17]: arr
Out[17]:
array([[[ 1,  2,  3],
        [ 4,  5,  6]],

       [[ 7,  8,  9],
        [10, 11, 12]]])

#高维数组的切片是沿着一个轴的方向进行选取的
In [21]: arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
In [22]: arr[:2]
Out[22]:
array([[1, 2, 3],
       [4, 5, 6]])
In [23]: arr[:2,1:]
Out[23]:
array([[2, 3],
       [5, 6]])
In [24]: arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
In [25]: arr[:2,:1,1:]
Out[25]:
array([[[2, 3]],

       [[8, 9]]])

#布尔型索引 布尔型索引数组元素的个数一定要和数据的第一个维度相同
In [26]: names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
In [27]: data = np.random.randn(7,4)
In [31]: data
Out[31]:
array([[ 0.31078785, -1.58765798, -1.53752375, -1.83930919],
       [ 1.29346975,  0.40328629,  2.41344244,  1.11255428],
       [ 0.91304775, -0.2961577 , -0.37833111, -0.01325506],
       [ 0.51463807, -0.48011605,  0.17400928,  1.07491798],
       [ 0.44332522, -0.33008212,  0.66016257, -0.43839193],
       [ 1.72179528,  0.40981819, -0.46940321,  0.365682  ],
       [ 1.14857783, -0.29801592,  0.20655081,  0.96203264]])
In [28]: names == 'Bod'
Out[28]: array([False, False, False, False, False, False, False])
In [30]: data[names == 'Bob']
Out[30]:
array([[ 0.31078785, -1.58765798, -1.53752375, -1.83930919],
       [ 0.51463807, -0.48011605,  0.17400928,  1.07491798]])
In [33]: data[names == 'Bob',2:] #还支持切片
Out[33]:
array([[-1.53752375, -1.83930919],
       [ 0.17400928,  1.07491798]])
In [34]: data[names == 'Bob',3]
Out[34]: array([-1.83930919,  1.07491798])

In [36]: data[names!='Bob']
Out[36]:
array([[ 1.29346975,  0.40328629,  2.41344244,  1.11255428],
       [ 0.91304775, -0.2961577 , -0.37833111, -0.01325506],
       [ 0.44332522, -0.33008212,  0.66016257, -0.43839193],
       [ 1.72179528,  0.40981819, -0.46940321,  0.365682  ],
       [ 1.14857783, -0.29801592,  0.20655081,  0.96203264]])
In [38]: data[~(names=='Bob')]
Out[38]:
array([[ 1.29346975,  0.40328629,  2.41344244,  1.11255428],
       [ 0.91304775, -0.2961577 , -0.37833111, -0.01325506],
       [ 0.44332522, -0.33008212,  0.66016257, -0.43839193],
       [ 1.72179528,  0.40981819, -0.46940321,  0.365682  ],
       [ 1.14857783, -0.29801592,  0.20655081,  0.96203264]])

In [41]: mask = (names == 'Bob')|(names =='Will') #and or在这儿无效，是能用& |
In [42]: mask
Out[42]: array([ True, False,  True,  True,  True, False, False])
In [43]: data[mask]
Out[43]:
array([[ 0.31078785, -1.58765798, -1.53752375, -1.83930919],
       [ 0.91304775, -0.2961577 , -0.37833111, -0.01325506],
       [ 0.51463807, -0.48011605,  0.17400928,  1.07491798],
       [ 0.44332522, -0.33008212,  0.66016257, -0.43839193]])

In [44]: data[data<0]=0 #小于0 的设置为 0
In [45]: data
Out[45]:
array([[0.31078785, 0.        , 0.        , 0.        ],
       [1.29346975, 0.40328629, 2.41344244, 1.11255428],
       [0.91304775, 0.        , 0.        , 0.        ],
       [0.51463807, 0.        , 0.17400928, 1.07491798],
       [0.44332522, 0.        , 0.66016257, 0.        ],
       [1.72179528, 0.40981819, 0.        , 0.365682  ],
       [1.14857783, 0.        , 0.20655081, 0.96203264]])

#花式索引，numpy术语，跟切片不一样，是把数据复制到新数组中
In [46]: arr = np.arange(32).reshape((8,4))
In [47]: arr
Out[47]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])
In [48]: arr[[1,5,7,2],[0,3,1,2]] #传入多个数组索引，最后返回一个一维数组，元素对应索引位置的元素
Out[48]: array([ 4, 23, 29, 10])

In [50]: arr[[1,5,7,2]][:,[0,3,1,2]] #这种方式得到数组的一个矩形区域，[1,5,7,2]指定了行，:指定了行中所有的元素，[0,3,1,2]指定了改行中元素出现的新的位置
Out[50]:
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])

In [52]: arr[np.ix_([1,5,7,2],[0,3,1,2])] # 使用 np.ix_(,)也能得到方形区域
Out[52]:
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])

In [78]: arr = np.empty((2,4))
In [80]: for i in range(2):
    ...:     arr[i] = i
In [81]: arr
Out[81]:
array([[0., 0., 0., 0.],
       [1., 1., 1., 1.]])